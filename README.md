# Yamato Daiwa CS(harp) extensions

![Hero image of "Yamato Daiwa CS(sharp) Extensions" library](https://repository-images.githubusercontent.com/669643442/5cd93629-36f7-4fa4-8868-42be9eb0de45)

## The extensions of the standard classes
### `DateOnly`

* `DateOnly CreateDateOnlyFromISO8601_String(string ISO8601_String)`
* `string ToISO8601_String()`


### `DateTime`

* `DateOnly CreateDateOnlyFromISO8601_String(string ISO8601_String)`
* `string ToISO8601_String()`


### `List`

* `List<TElement> AddElementsToEnd<TElement> (params TElement[] newElements) `
* `AddElementToEndIf`
  * `List<TElement> AddElementToEndIf<TElement>(TElement newElement, bool condition)`
  * `List<TElement> AddElementToEndIf<TElement>(TElement newElement, Func<TElement?, bool> condition)`
* `StringifyEachElementAndJoin<TElement>(string separator)` 
* `ReplaceArrayElementsByPredicate`
  * `List<TElement> ReplaceArrayElementsByPredicate<TElement>(Func<TElement, bool> predicate, TElement newElement, bool mustReplaceOnlyFirstOne)`
  * `List<TElement> ReplaceArrayElementsByPredicate<TElement>(Func<TElement, bool> predicate, Func<TElement, TElement> replacer, bool mustReplaceOnlyFirstOne)`


### `String`

* `bool IsNonEmpty()`
* `string ToUpperCamelCase()`
* `string ToLowerCamelCase()`
* `string RemoveAllSpecifiedCharacters(char[] charactersToRemove)`


## Random values generators (`RandomValuesGenerator` class)

* `bool GetRandomBoolean()`
* `byte GetRandomByte(byte minimalValue = Byte.MinValue, byte maximalValue = Byte.MaxValue)`
* `ushort GetRandomUShort(ushort minimalValue = ushort.MinValue, ushort maximalValue = ushort.MaxValue)`
* `TArrayElement GetRandomArrayElement<TArrayElement>(TArrayElement[] targetArray)`
* `DateOnly GetRandomDate(DateOnly earliestDate, DateOnly latestDate)`
* `DateTime GetRandomDateTime(DateOnly earliestDate, DateOnly latestDate)`


## Data mocking
### `DataMocking` class
#### `NullablePropertiesDecisionStrategies` enumeration

<dl>

  <dt><code>mustGenerateAll</code></dt>
  <dd>All nullable (optional) properties must be generated except the cases of incompatible properties.</dd>

  <dt><code>mustGenerateWith50PercentageProbabilityIfHasNotBeenPreDefined</code></dt>
  <dd>Nullable (optional) properties must be generated with 50% probability.</dd>

  <dt><code>mustSkipIfHasNotBeenPreDefined</code></dt>
  <dd>Nullable (optional) properties must <em>not</em> be randomly generated.</dd>

</dl>


#### `DecideOptionalValue` static method and `NullablePropertiesDecisionSourceDataAndOptions` structure

```
TValueType? DecideOptionalValue<TValueType>(NullablePropertiesDecisionSourceDataAndOptions<TValueType> sourceDataAndOptions)
```

```csharp
struct NullablePropertiesDecisionSourceDataAndOptions<TPropertyType>
{
  public required NullablePropertiesDecisionStrategies Strategy { get; init; }
  public required Func<TPropertyType> RandomValueGenerator? { get; init; }
  public TPropertyType? PreDefinedValue { get; init; }
}
```

Decides, will nullable (optional) value be available or no, and if yes, returns this value.
Intended to be used when generating the properties for the class / structure.

The decision will depend mainly on specified nullable property decision strategy:

<dl>

  <dt><code>mustGenerateAll</code></dt>
  <dd>
    If target nullable property has <em>not</em> been predefined via <code>NullablePropertiesDecisionStrategies.PreDefinedValue</code>, 
      it will be generated by specified <code>RandomValueGenerator</code>.
    It means the <code>RandomValueGenerator</code> must be specified for this strategy, 
      otherwise <code>ArgumentException</code> will be thrown.
  </dd>

  <dt><code>mustGenerateWith50PercentageProbabilityIfHasNotBeenPreDefined</code></dt>
  <dd>
    If target nullable property has been predefined via <code>NullablePropertiesDecisionStrategies.PreDefinedValue</code>,
      this value will be returned otherwise will be generated by specified <code>RandomValueGenerator</code> with
      probability 50%.
    It means the <code>RandomValueGenerator</code> must be specified for this strategy, 
      otherwise <code>ArgumentException</code> will be thrown.
  </dd>

  <dt><code>mustSkipIfHasNotBeenPreDefined</code></dt>
  <dd>
    If target nullable property has <em>not</em> been predefined via <code>NullablePropertiesDecisionStrategies.PreDefinedValue</code>,
      no random value will be generated.
    Only for the strategy <code>RandomValueGenerator</code> should be omitted. 
  </dd>

</dl>


### Errors classes

<dl>

  <dt><code>DataRetrievingFailedException</code></dt>
  <dd>Intended to be used when the data retrieving from some external resource (server, database, file, etc.) failed.</dd>

  <dt><code>DataSubmittingFailedException</code></dt>
  <dd>Intended to be used when the data submitting to any external resource (server, database, etc.) failed.</dd>

</dl>

### `MockGatewayHelper` class

When mock the asynchronous data transactions, takes care about such routines as

1. Randomizing of the pending interval
2. Simulation of the error
3. Logging


### Public static methods
#### `SimulateDataRetrieving`

```csharp
Task<TResponseData> SimulateDataRetrieving<TRequestParameters, TResponseData>(
  TRequestParameters requestParameters,
  Func<TResponseData> getResponseData,
  SimulationOptions options
)
```

where the `SimulationOptions` is the associated **structure** will be [described below](#associated-structure-simulationoptions).


#### `SimulateDataSubmitting`

```csharp
public static async Task<TResponseData> SimulateDataSubmitting<TRequestData, TResponseData>(
  TRequestData requestData,
  Func<TResponseData> getResponseData,
  SimulationOptions options
)
```

It's behaviour is almost even with `SimulateDataRetrieving`, but there are some differences:

* The logging
* `DataSubmittingFailedException` will be thrown instead of `DataRetrievingFailedException` when error simulation mode
  is enabled.


### Associated structure `SimulationOptions`

```csharp
public struct SimulationOptions
{
  public ushort? MinimalPendingPeriod__Seconds { get; init; }
  public ushort? MaximalPendingPeriod__Seconds { get; init; }
  public bool MustSimulateError { get; init; }
  public bool MustLogResponseData { get; init; }
  public required string GatewayName { get; init; }
  public required string TransactionName { get; init; }
}
```

<dl>

  <dt>MinimalPendingPeriod__Seconds</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>ushort</code></dd>
      <dt>Default value</dt>
      <dd><code>1</code></dd>
      <dt>Use case</dt>
      <dd>If you want see the loading placeholder for the while increase this value.</dd>
    </dl>
  </dd>

  <dt>MaximalPendingPeriod__Seconds</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>ushort</code></dd>
      <dt>Default value</dt>
      <dd><code>2</code></dd>
      <dt>Use case</dt>
      <dd>If you want see the loading placeholder for the while increase this value.</dd>
    </dl>
  </dd>

  <dt>MustSimulateError</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>book</code></dd>
      <dt>Default value</dt>
      <dd><code>false</code></dd>
      <dt>Use case</dt>
      <dd>If you want to check is the error message displaying well in your GUI, set this flag to <code>true</code>.</dd>
    </dl>
  </dd>

  <dt>MustSimulateError</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>bool</code></dd>
      <dt>Is required</dt>
      <dd>Yes</dd>
    </dl>
  </dd>

  <dt>MustLogResponseData</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>bool</code></dd>
      <dt>Is required</dt>
      <dd>Yes</dd>
      <dt>Note</dt>
      <dd><code>System.Text.Json.JsonSerializer</code> will be used for serializing.</dd>
    </dl>
  </dd>

  <dt>GatewayName</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>bool</code></dd>
      <dt>Is required</dt>
      <dd>Yes</dd>
      <dt>Note</dt>
      <dd>Used for the logging only. "Gateway" could be called "service" in you code.</dd>
    </dl>
  </dd>

  <dt>TransactionName</dt>
  <dd>
    <dl>
      <dt>Type</dt>
      <dd><code>bool</code></dd>
      <dt>Is required</dt>
      <dd>Yes</dd>
      <dt>Note</dt>
      <dd>Used for the logging only.</dd>
    </dl>
  </dd>

</dl>


